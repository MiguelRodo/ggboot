% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calcBootEst.R
\name{calcCITbl}
\alias{calcCITbl}
\title{calculate confidence intervals for multiple groups}
\usage{
calcCITbl(bootData, alpha, method, diff, bcaAVec, createCluster = FALSE)
}
\arguments{
\item{bootData}{dataframe. Must have character column split, defining
groups, and bootStat, giving \code{B} bootstrap sample estimates for each
group in \code{split} of statistic for which confidence interval is required. If
\code{method=='percT'}, then}

\item{alpha}{numeric \eqn{\;\in(0,1)}. (1-alpha) is the desired coverage
for the confidence interval.}

\item{method}{'bca', 'bc' or 'perc'. The confidence interval method.}

\item{diff}{logical. If \code{TRUE}, then the acceleration factor, $a$, is
forced to zero, even when \code{method=='bca'}. This is because the acceleration factor
calculated is invalid in the unpaired two-sample case. The reported acceleration factor
is set to \code{NA}, for the same reason. If \code{diff==TRUE}, then the acceleration factor
is only zero if \code{method=="bc"}, and the acceleration factor is reported as is.}

\item{bcaAVec}{numeric vector. Numeric vector of . Required only if bcaAVec}

\item{createCluster}{logical. If \code{TRUE}, then the code to start a cluster is run.}
}
\value{
A tibble with columns named split, lb and ub.
}
\description{
Calculates confidence intervals using one of three methods (BCa, BC or percentile),
as well as the bias factor ($z_0$) and the acceleration factor ($a$).
}
\examples{
# data prep
respVec = c( 0.060426, 0.066152, 0.07093, 0.056687, 0.18716, 0.790952, 0.20803, 0.245396, 0.087918,
0.02499226, 0.2234444308, 0.0148025445, 0.2425358694, 0.025742255, 0.011875387, 0.0148772707,
0.0086363158, 0.014349707, 0.0087206469, 0.055159961, 0.0366530097, 0.000260970000000001, 0.0111716045, 0.011851586,
0.0109080046, 0.002077461, 0.011693718, 0.0182342151, 0.0031248769, 0.0067057876, 0.0172261736,
0.0491776258, 0.026822441, 0.0062511869, 0.0135163775, 0.003760361, 0.0196274421, 0.004280863, 0.0143105389,
0.0150681214, 0.0063319547, 0.0087206469, 0.000260970000000001, 0.0111716045, 0.002077461, 0.011693718, 0.0148772707,
0.055159961, 0.0366530097, 0.011851586, 0.0109080046, 0.0182342151, 0.0172261736, 0.026822441, 0.0135163775 )
splitVec = c( rep( "1", 9), rep( "2", 46 ) )
calcStat = function(x) mean( x, trim = 0.2 )
calcStatVec = calcStat
calcBootStatVec = function(x,w) calcStatVec(x[w])

origStatTbl = plyr::ldply( split( respVec, splitVec ),
                       calcStatVec ) \%>\%
 rename( split = .id, origStat = V1 )

origStatVec = setNames( origStatTbl$origStat, origStatTbl$split )

bcaATbl = plyr::ldply( split( respVec, splitVec ), function(x) calcBCaA( x, calcStat ) ) \%>\%
 rename( split = .id, bcaA = V1 )

bcaAVec = setNames( bcaATbl$bcaA, bcaATbl$split )

set.seed(1)
bootTbl = plyr::ldply( split( respVec, splitVec ),
                      function(x) boot::boot( x, calcBootStatVec, 1e2 )$t ) \%>\%
 rename( split = .id, bootStat = `1` ) \%>\%
 mutate( origStat = origStatVec[ split ] ) \%>\%
 as_tibble()

 # actual function
 calcCITbl( bootData = bootTbl, alpha = 0.05, method = "bca",
diff = FALSE, bcaAVec = bcaAVec )
}
